package main

import "fmt"

func gradationBy10(temp float64)string{
	x:=int(temp/10)
	//так, как у нас 0 является центром координат(переход от отрицательных чисел к положительным),
	//то нужно это учесть при работе с отрицательными числами,
	//и сделать сдвиг переменной на 1 градацию, что бы результат был правильным
	if temp<0{
		x--
	}
	//формируем градации не так, как показано в условиях, потому что, если делать по условиям, то получаем такое:
	//при входных данных -25.4, -27.0 13.0, 19.0, 15.5, 24.5, -21.0, 32.5,
	//градации будут такими: -20:{-25.0, -27.0, -21.0}, 10:{13.0, 19.0, 15.5}, 20: {24.5}
	//тогда, продолжим пример и сделаем градации для отрицательных чисел: -15.0, -5.0
	//в соответствии логике примера, получаем результат: -10:{-15.0}, 0:{-5.0},
	//продолжим дополнять данные положительными числами: 5.0,
	//получаем: 0:{5.0}. Но так не может быть. Если числа от -10 до 0 и числа от 0 до 10
	//являются частью группы 0, то нарушается условие задачи: Объединить данные значения в группы с шагом в 10
	//градусов, поскольку группа 0 будет иметь шаг в 20 градусов.
	//с данными рассуждениями писал в чат Левану(@liongodevs), но ответа не получил.
	//Придерживаюсь правила: куратор/руководитель не отреагировал, значит я на верном пути
	return fmt.Sprintf("от %.1f до %.1f",float64(x*10),float64((x+1)*10))
}
func gradateTemps(temps []float64) map[string][]float64{
	tmpMap:=make(map[string][]float64)
	for _,temp:=range temps{
		gradation:=gradationBy10(temp)
		//для хранения результатов программы использую карту, потому что так удобно
		tmpMap[gradation]=append(tmpMap[gradation],temp)
	}
	return tmpMap
}
func prob10(){
	input:=[]float64{-25.4, -27.0, 13.0, 19.0,
		15.5, 24.5, -21.0, 32.5}
	result:=gradateTemps(input)
	for k,v:=range result{
		fmt.Println(k,":",v)
	}
}