package main

import (
	"fmt"
)

var justString string

func StringSlice(input string,start int, end int)string{
	tmp:=[]rune(input)
	var res []rune
	for i:=start;i<end;i++{
		res=append(res,tmp[i])
	}
	return string(res)
}

func createHugeString(n int)string{
	str:=""
	for i:=0;i<n;i++{
		//используем символ, занимающий больше 1 байта для демонстрации негативных последствий
		str+="♥"
	}
	return str
}
func someFunc() {
	//изначально думал, что негативные последствия будут те же, что и работа со срезами:
	//меняя данные среза, мы меняем и данные массива, с которого этот срез сформирован
	//затем сделал такую проверку:
	/*
		a:="123123"
		b:=a[:5]
		fmt.Printf("&a=%v &a[0]=%v",&[]byte(a)[0],&[]byte(b)[0])
	*/
	//следуя из результатов, видно, что первый байт начальной строки и первый байт результирующей строки
	//имеют разные указатели. Следуюя из этого, можно принять как данность: меняя данные результирующей строки
	//мы никак не изменим данные первой строки.
	//Тогда это предположение отпадает
	v := ""
	v=createHugeString(1<<10)
	fmt.Printf("Первые 100 'символов' хьюдж стринга:\t\t%s\n",v[:100])
	justString = v[:100]
	fmt.Printf("Джаст стринг курильщика:\t\t\t\t\t%s\n",justString)
	//делаю вывод, что указанным выше способом мы работаем не со срезом символов, а со срезом байтов.
	//если символ занимает места больше, чем 1 байт, то программа выдаст результат, которого мы не ожидаем:)
	//значит надо работать со срезом символов
	justString=string([]rune(v)[:100])
	fmt.Printf("Джаст стринг здорового человека:\t\t\t%s\n",justString)
}

func prob15(){
	someFunc()
}

