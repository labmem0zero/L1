package main

import (
	"fmt"
)

func Sort(in []int, left int, right int)[]int {
	//задаем левый и правый индекс для итерирования
	l:=left
	r:=right
	//центральная точка среза(пивот), используется для сравнения.
	//На самом деле можно использовать любую, но в среднем
	//центральная точка дает лучший результат
	center:=in[(left+right)/2]
	for l<=r{
		//итерируем,начиная с левой части до тех пор, пока элемент среза не станент больше,
		//либо равен центральному
		for in[l]<center{
			l++
		}
		//итерируем,начиная с правой части до тех пор, пока элемент среза не станент меньше,
		//либо равен центральному
		for in[r]>center{
			r--
		}
		//если "левый" элемент по индексу меньше "правого", то меняем их местами, так как
		//по значению все наоборот:
		//l<r при in[l]>in[r]
		if l<=r{
			in[r],in[l]=in[l],in[r]
			//не забываем сделать инкремент и декремент l и r соответственно
			l++
			r--
		}
		//итерируем дальше
	}
	//если после всех итераций r больше left(	r - итератор для правой части,
	//											left - начальная левая точка внутри текущей функции)
	//то делаем рекуррентный вызов функции, используя в качестве left и right значения left и r
	//это позволит в новой функции отсортировать часть среза от 0 до r, последнего отсортированного элемента
	//при этом пивотом станет уже центральая точка между 0 и r
	if r>left{
		Sort(in,left,r)
	}
	//аналогично прошлому условию, только уже для правой части
	if l<right{
		Sort(in,l,right)
	}
	//когда сортировать уже нечего, возвращаем результат
	return in
}

func prob16(){
	a:=[]int{5,2,7,1,8,8}
	fmt.Println(a)
	a=Sort(a,0,len(a)-1)
	fmt.Println(a)
}
