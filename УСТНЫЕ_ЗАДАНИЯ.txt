1. Какой самый эффективный способ конкатенации строк?
strings.Join()
на втором месте s=a+b
https://andrey.4devs.io/ru/golang/string-concatenation-golang.html

2. Что такое интерфейсы, как они применяются в Go?
Интерфейс - абстракция, позволяющая описывать обобщенное поведение различных объектов.
Применяется в Go для упрощения кода, повышения его удобочитаемости.
Как пример, у нас есть различные структуры, отдающие данные методом GetDataFormattedJSON()
если нам нужно получить данные всех этих структур, то без использования интерфейса получим нечто вроде:
data1:=struct1.GetDataFormattedJSON()
data2:=struct2.GetDataFormattedJSON()
...
dataN:=structN.GetDataFormattedJSON()

При использовании же интерфейса, можно сократить код и повысить удобочитаемость:
data1:=getJSON(struct1)
data2:=getJSON(struct2)
...
dataN:=getJSON(structN)

Кроме того, существуют различные паттерны, задествующие интерфейсы(например, паттерн Adapter,
позволяющий реализовывать схожие разноименные методы для различных структур, вуалируя реализацию в один метод
с одинаковым для всех структур названием)

3. Чем отличаются RWMutex от Mutex?
RWMutex позволяет считывать данные, даже если запись заблокирована


4. Чем отличаются буферизированные и не буферизированные каналы?
Буферизированные каналы обладают емкостью. Пока канал не будет заполнен, он не будет блокировать поток в ожидании "разгрузки"


5. Какой размер у структуры struct{}{}?
0 байт


6. Есть ли в Go перегрузка методов или операторов?
нет

7. В какой последовательности будут выведены элементы map[int]int?
Пример:
m[0]=1
m[1]=124
m[2]=281
С 0 по последний

8. В чем разница make и new?
make возращает объект, new возвращает указатель на объект

9. Сколько существует способов задать переменную типа slice или map?
3 способа

var a[]int
a:=[]int{}
a:=new([]int)

var m map[int]int
m:=map[int]int{}
m:=make(map[int]int)

10. Что выведет данная программа и почему?
func update(p *int) {
	b := 2
	p = &b
}
func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	update(p)
	fmt.Println(*p)
}

Выведет 1 в обоих случаях, потому что функция update работает не с переменной, а с ее указателем(который тоже является переменной).
В итоге мы меняем не переменную, а указатель. Можно провести эксперимент:
func update(p *int, s *int) {
	b := 2
	p = s
	*p=b
}

func main() {
	var (
		a = 1
		b=5
		p = &a
		s=&b
	)
	fmt.Println(*p,*s)
	update(p,s)
	fmt.Println(*p,*s)
}
В данном случае мы в функции апдейт присваиваем указателю первого числа(p) указатель второго числа(s),
После разименования переменной 'p' и ее модификации, мы модифицировали значение не первого входного числа, а второго

Что бы изменить значение входной переменной, как изначально и задумывалось, ее сначала нужно разименовать:
	"p = &a" заменить на "*p = b"

11. Что выведет данная программа и почему?
func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}
Паника по поводу дедлока, ибо в функцию передается копия начального sync.WaitGroup и она же модифицируется при помощи wg.Done(),
в то время, как за пределами горутин, в wg добавляются задания, завершения которых ждет wg.Wait()
Учитывая, что go func() у нас находится внутри пространства имен, где уже есть wg := sync.WaitGroup{}, то мы можем
не передавать его в функцию, а можем работать с ним напрямую

12. Что выведет данная программа и почему?
func main() {
	n := 0
	if true {
		n := 1
		n++
	}
	fmt.Println(n)
}
Выведет 0, поскольку внутри пространства имен if создается новая переменная n, с ней и проводятся все опреации.
Как и в прошлом случае, мы должны работать с уже существующей переменной:
заменить 'n:=1' на 'n=1'

13. Что выведет данная программа и почему?
func someAction(v []int8, b int8) {
	v[0] = 100
	v = append(v, b)
}
func main() {
	var a = []int8{1, 2, 3, 4, 5}
	someAction(a, 6)
	fmt.Println(a)
}
100, 2, 3, 4, 5
Первый элемент изменился, потому что в функции someAction мы работаем с копией среза. Но распределение памяти в Go устроено так, что меняя значения среза,
мы меняем значения и массива, на основе которого сделан срез.
Новый элемент в результате не появился, потому что при добавлении элемента в срез, Go проверяет, укладывается ли новый срез в capacity(ёмкость) изначального массива.
Если нет, то программа создает новый массив с емкостью, достаточной для хранения нового среза, который затем и возращает.
Но так, как функция работает с копией среза('v []int8', а не 'v *[]int8'), то старый срез не будет заменен на новый.
Для того, что бы добиться ожидаемого результата, нужно сделать так:
func someAction(v *[]int8, b int8) {
	(*v)[0] = 100
	*v = append(*v, b)
}
func main() {
	var a = []int8{1, 2, 3, 4, 5}
	someAction(&a, 6)
	fmt.Println(a)
}

14. Что выведет данная программа и почему?
func main() {
	slice := []string{"a", "a"}
	func(slice []string) {
		slice = append(slice, "a")
		slice[0] = "b"
		slice[1] = "b"
		fmt.Print(slice)
	}(slice)
	fmt.Print(slice)
}
Первая часть вывода будет [b b a] потому что:
1) К копии входного среза добавляется еще один элемент "a"
В этот момент срез представляет из себя [a a a]
2) Первые два его элемента изменяются на "b" и "b"
В этот момент срез представляет из себя [b b a]
Этот срез выводится внутри функции.

Как уже было сказано, функция работает с копией среза. Но так, как сначала мы прибавляем еще один элемент к начальному срезу
то из-за нехватки его емкости, создается новый массив и возращается основанный уже на нем срез. И уже его элементы модифицируются
Именно поэтому, после выполнения функции, во второй части вывода мы видим [a a](начальные данные). Потому что они никак не могли быть модифицированны.